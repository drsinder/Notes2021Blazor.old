@using Notes2021Blazor.Shared
@using System.Timers
@inject NavigationManager NavigationManager
@inject HttpClient Http
@inject IModalService Modal
@inject IJSRuntime jsRuntime

@if (string.IsNullOrEmpty(curN))
{
    <p class="center"><em>Loading...</em></p>
}
else if (newnoteFlag)
{
    <NoteEditorPanel Model="@Model" BaseNoteId=@currentHeader.BaseNoteId OnClick="ClickHandler" />
}
else if (editing)
{
    <NoteEditorPanel Model="@Model" BaseNoteId=@currentHeader.BaseNoteId EditHeader="@currentHeader" NoteContent="@currentContent" OnClick="ClickHandler" />
}
else
{
    @*<div class="modal-dialog-scrollable">
            <BlazoredModal />
        </div>*@
    <h4 class="text-center">@Model.noteFile.NoteFileTitle</h4>
    <hr id="premenu" />
    <DisplayMenu Model="@Model" OnClick="ClickHandler" />
    <div class="noteheader">
        <p>
            <span class="keep-right">Note: @currentHeader.NoteOrdinal @respX&nbsp;&nbsp;&nbsp;&nbsp;</span>
        </p>

        <h4>
            Subject: @currentHeader.NoteSubject <br />
            Author: @currentHeader.AuthorName &nbsp;&nbsp;&nbsp;
            @(Model.tZone.Local(currentHeader.LastEdited).ToLongDateString()) @(Model.tZone.Local(currentHeader.LastEdited).ToShortTimeString()) @Model.tZone.Abbreviation
            @if (!string.IsNullOrEmpty(currentContent.DirectorMessage))
            {
                <br /><span>Director Message: @currentContent.DirectorMessage</span>
            }
            @if (tags != null && tags.Count > 0)
            {
                string tl = "Tags: ";
                foreach (Tags tag in tags)
                    tl += tag.Tag + " ";
                <br /><span>@tl</span>
            }
        </h4>
    </div>
    <div class="notebody">
        @((MarkupString)currentContent.NoteBody)
    </div>

    <DisplayMenu Model="@Model" OnClick="ClickHandler" />
    <button @onclick="Done">Done Reading</button>

    <div class="arrow2">
        <div>
            <EditForm Model="@myInput" Context="EditBox">
                <InputText id="arrow2" autofocus="@myInput.isAutoFocus" @onkeypress="KeyPressed"
                           ValueChanged="@( (string val) => TextHasChanged(val) )"
                           Value="@myInput.typedValue"
                           ValueExpression="@( () => myInput.typedValue )" /> #= <strong>@curN</strong>
                    </EditForm>

                    <br /><input type="submit" value="Navigate" class="btn btn-sm" /> b#.r#&nbsp;&nbsp;|&nbsp;&nbsp;(+/-)b#&nbsp;&nbsp;|&nbsp;&nbsp;(+/-).r#
                </div>
            </div>
        }

@functions
{
    [Parameter] public NoteDisplayIndexModel Model { get; set; }
    [Parameter] public NoteHeader currentHeader { get; set; }
    [Parameter] public int Id { get; set; }

    protected bool newnoteFlag { get; set; }
    protected bool editing { get; set; }

    private Timer timer { get; set; }

    public string respX { get; set; }

    public NoteContent currentContent { get; set; }

    public List<Tags> tags;

    string curN { get; set; }

    LocalInput myInput { get; set; }

    [Parameter] public EventCallback<string> OnClick { get; set; }

    protected async override Task OnParametersSetAsync()
    {
        Model.myHeader = currentHeader;
        myInput = new LocalInput();
        myInput.isAutoFocus = true;

        newnoteFlag = false;
        editing = false;

        DisplayModel dm = await Http.GetJsonAsync<DisplayModel>("api/NoteContent/" + currentHeader.Id);

        currentContent = dm.content;
        tags = dm.tags;


        respX = "";
        if (currentHeader.ResponseCount > 0)
            respX = " - " + currentHeader.ResponseCount + " Responses ";

        curN = "" + currentHeader.NoteOrdinal;
        if (currentHeader.ResponseOrdinal > 0)
        {
            curN += "." + currentHeader.ResponseOrdinal;
        }

    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            timer = new Timer(1000);
            timer.Elapsed += TimerTick;
            timer.Enabled = true;
        }
    }

    protected void TimerTick(Object source, ElapsedEventArgs e)
    {
        jsRuntime.InvokeAsync<object>("setfocus", "arrow2");
    }

    public async Task ClickHandler(string newMessage)
    {
        if (newMessage == "ShowHelp")
        {
            ShowHelp();
        }
        else if (newMessage == "NextBaseNote")
        {
            await NextBaseNote();
        }
        else if (newMessage == "PreviousBaseNote")
        {
            await PreviousBaseNote();
        }
        else if (newMessage == "NextNote")
        {
            await TextHasChanged("");
        }
        else if (newMessage == "PreviousNote")
        {
            await PreviousNote();
        }
        else if (newMessage == "NewResponse")
        {
            newnoteFlag = true;
            this.StateHasChanged();
        }
        else if (newMessage == "Edit")
        {
            editing = true;
            this.StateHasChanged();
        }
        else if (newMessage == "Delete")
        {
            DeleteNote();
        }
        else  // pass on to list parent
        {
            await OnClick.InvokeAsync(newMessage);
        }
    }

    protected void DeleteNote()
    {
        var parameters = new ModalParameters();
        parameters.Add("NoteId", currentHeader.Id);
        parameters.Add("FileId", Model.noteFile.Id);
        var options = new ModalOptions() { HideCloseButton = false };
        Modal.OnClose += HideDialog;
        Modal.Show<DeleteNote>("", parameters, options);
    }

    protected async Task KeyPressed(KeyboardEventArgs eventArgs)
    {
        switch (eventArgs.Key)
        {
            case "Z": ShowHelp(); break;
            case "E":
                if (@Model.myAccess.DeleteEdit || Model.myHeader.AuthorID == Model.myAccess.UserID)
                    editing = true;
                StateHasChanged();
                break;
            case "D":
                if (@Model.myAccess.DeleteEdit || Model.myHeader.AuthorID == Model.myAccess.UserID)
                    DeleteNote();
                break;
            case "Enter":
                if (!eventArgs.ShiftKey)
                    await TextHasChanged("");
                else
                    await NextBaseNote();
                break;
            case "b":
                await PreviousNote();
                break;
            case "B":
                await PreviousBaseNote();
                break;
            case "N":
                newnoteFlag = true;
                this.StateHasChanged();
                break;
            case "L":
            case "I":
                Done();
                break;
            default:
                //var parameters = new ModalParameters();
                //parameters.Add("Message", eventArgs.Key);
                //var options = new ModalOptions() { HideCloseButton = false };
                //Modal.OnClose += HideDialog;
                //Modal.Show<MessageBox>("", parameters, options);
                break;
        }

    }

    protected async Task SetNote()
    {
        DisplayModel dm = await Http.GetJsonAsync<DisplayModel>("api/NoteContent/" + currentHeader.Id);

        currentContent = dm.content;
        tags = dm.tags;

        respX = "";
        if (currentHeader.ResponseOrdinal > 0)
        {
            NoteHeader bnh = Model.Notes.Find(p => p.Id == currentHeader.BaseNoteId);
            respX = " - Response " + currentHeader.ResponseOrdinal + " of " + bnh.ResponseCount;
        }
        else if (currentHeader.ResponseCount > 0)
            respX = " - " + currentHeader.ResponseCount + " Responses ";


        curN = "" + currentHeader.NoteOrdinal;
        if (currentHeader.ResponseOrdinal > 0)
        {
            curN += "." + currentHeader.ResponseOrdinal;
        }
        Model.myHeader = currentHeader;
        this.StateHasChanged();
    }

    protected async Task PreviousBaseNote()
    {
        if (currentHeader.NoteOrdinal == 1)
            return;
        currentHeader = Model.Notes.Find(p => p.NoteOrdinal == currentHeader.NoteOrdinal - 1 && p.ResponseOrdinal == 0);
        if (currentHeader == null)
            return;
        await SetNote();
    }

    protected async Task NextBaseNote()
    {
        NoteHeader newbase = Model.Notes.Find(p => p.NoteOrdinal == currentHeader.NoteOrdinal + 1 && p.ResponseOrdinal == 0);
        if (newbase == null)
            return;
        currentHeader = newbase;
        await SetNote();
    }

    protected async Task PreviousNote()
    {
        if (currentHeader.ResponseOrdinal == 0)
        {
            await PreviousBaseNote();
            return;
        }
        NoteHeader newbase = Model.AllNotes.Find(p => p.NoteOrdinal == currentHeader.NoteOrdinal && p.ResponseOrdinal == currentHeader.ResponseOrdinal - 1);
        if (newbase == null)
            return;

        currentHeader = newbase;
        await SetNote();
    }

    private void Done()
    {
        OnClick.InvokeAsync("Done:" + currentHeader.NoteOrdinal);
    }

    private async Task TextHasChanged(string typedInput)
    {
        int fileId = Id;
        int iOrd = currentHeader.NoteOrdinal;
        int iResp = currentHeader.ResponseOrdinal;
        long iNoteId = currentHeader.Id;
        int noteOrd = 1;
        NoteHeader nc;
        NoteHeader bnh = Model.Notes.Find(p => p.Id == currentHeader.BaseNoteId);
        bool ax = false;
        bool plus = false;
        bool minus = false;

        typedInput = typedInput.Trim().Replace("'\n", "").Replace("'\r", "").Trim();

        if (string.IsNullOrEmpty(typedInput) || string.IsNullOrWhiteSpace(typedInput))
        {
            // next note
            NoteHeader searcher = Model.AllNotes.Find(p => p.NoteOrdinal == currentHeader.NoteOrdinal && p.ResponseOrdinal == currentHeader.ResponseOrdinal + 1);
            if (searcher != null)  // found a response
            {
                nc = searcher;
                bnh = Model.Notes.Find(p => p.NoteOrdinal == currentHeader.NoteOrdinal);

                goto beyond;
            }
            searcher = Model.Notes.Find(p => p.NoteOrdinal == currentHeader.NoteOrdinal + 1);
            if (searcher != null) // found a base
            {
                nc = bnh = searcher;
                goto beyond;
            }
            Done();  // reached the end
        }

        if (typedInput.StartsWith("+"))
            plus = true;
        if (typedInput.StartsWith("-"))
            minus = true;
        typedInput = typedInput.Replace("+", "").Replace("-", "");

        if (typedInput.Contains("."))
        {
            string[] splits = typedInput.Split(new[] { '.' });
            if (splits.Length != 2)
            {
                return;
            }
            if (string.IsNullOrEmpty(splits[0]) || string.IsNullOrWhiteSpace(splits[0]))
                noteOrd = iOrd;
            else
                ax = !int.TryParse(splits[0], out noteOrd);
            bool bx = !int.TryParse(splits[1], out var respOrd);
            if (ax || bx)
            {
                return;
            }

            if (noteOrd == iOrd && (plus || minus))
            {
                if (plus)
                    respOrd += iResp;
                else
                    respOrd = iResp - respOrd;

                if (respOrd < 0)
                    respOrd = 0;
                bnh = Model.Notes.Find(p => p.NoteOrdinal == noteOrd);

                if (respOrd > bnh.ResponseCount) respOrd = bnh.ResponseCount;
            }

            nc = Model.AllNotes.Find(p => p.NoteOrdinal == noteOrd && p.ResponseOrdinal == respOrd);
        }
        else
        {
            if (!int.TryParse(typedInput, out noteOrd))
            {
                return;
            }

            if (!plus && !minus && (noteOrd == 0))
            {
                Done();
            }
            if (plus)
                noteOrd += iOrd;
            else if (minus)
                noteOrd = iOrd - noteOrd;

            if (noteOrd < 1) noteOrd = 1;

            long cnt = Model.AllNotes.LongCount();

            if (noteOrd > cnt) noteOrd = (int)cnt;

            nc = Model.Notes.Find(p => p.NoteOrdinal == noteOrd);
            bnh = nc;
        }

        if (nc == null)
        {
            return;
        }

    beyond:

        currentHeader = nc;

        DisplayModel dm = await Http.GetJsonAsync<DisplayModel>("api/NoteContent/" + currentHeader.Id);

        currentContent = dm.content;
        tags = dm.tags;

        respX = "";
        if (currentHeader.ResponseOrdinal > 0)
        {
            respX = " - Response " + currentHeader.ResponseOrdinal + " of " + bnh.ResponseCount;
        }
        else if (bnh.ResponseCount > 0)
            respX = " - " + bnh.ResponseCount + " Responses ";

        curN = "" + bnh.NoteOrdinal;
        if (currentHeader.ResponseOrdinal > 0)
        {
            curN += "." + currentHeader.ResponseOrdinal;
        }
        Model.myHeader = currentHeader;
        this.StateHasChanged();
    }

    private void ShowHelp()
    {
        var parameters = new ModalParameters();
        Modal.OnClose += HideDialog;
        var options = new ModalOptions() { HideCloseButton = false };
        Modal.Show<HelpDialog2>("", parameters, options);
    }

    void HideDialog(ModalResult modalResult)
    {
        Modal.OnClose -= HideDialog;
    }

    protected class LocalInput
    {
        public string typedValue { get; set; }
        public bool isAutoFocus { get; set; }
    }

}
